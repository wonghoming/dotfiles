'use strict';

Object.defineProperty(exports, '__esModule', {
  value: true
});

var _types;

function _load_types() {
  return (_types = require('./types'));
}

var _child_process;

function _load_child_process() {
  return (_child_process = require('child_process'));
}

var _fs;

function _load_fs() {
  return (_fs = require('fs'));
}

var _os;

function _load_os() {
  return (_os = require('os'));
}

var _events;

function _load_events() {
  return (_events = _interopRequireDefault(require('events')));
}

var _project_workspace;

function _load_project_workspace() {
  return (_project_workspace = _interopRequireDefault(
    require('./project_workspace')
  ));
}

var _Process;

function _load_Process() {
  return (_Process = require('./Process'));
}

function _interopRequireDefault(obj) {
  return obj && obj.__esModule ? obj : {default: obj};
}

function _toConsumableArray(arr) {
  if (Array.isArray(arr)) {
    for (var i = 0, arr2 = Array(arr.length); i < arr.length; i++)
      arr2[i] = arr[i];
    return arr2;
  } else {
    return Array.from(arr);
  }
}
/**
 * Copyright (c) 2014-present, Facebook, Inc. All rights reserved.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE file in the root directory of this source tree.
 *
 *
 */

// This class represents the running process, and
// passes out events when it understands what data is being
// pass sent out of the process
class Runner extends (_events || _load_events()).default {
  constructor(workspace, options) {
    super();

    this._createProcess =
      (options && options.createProcess) ||
      (_Process || _load_Process()).createProcess;
    this.options = options || {};
    this.workspace = workspace;
    this.outputPath = (0, (_os || _load_os()).tmpdir)() + '/jest_runner.json';
    this.prevMessageTypes = [];
  }

  start() {
    let watchMode =
      arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : true;
    let watchAll =
      arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : false;

    if (this.debugprocess) {
      return;
    }

    this.watchMode = watchMode;
    this.watchAll = watchAll;

    // Handle the arg change on v18
    const belowEighteen = this.workspace.localJestMajorVersion < 18;
    const outputArg = belowEighteen ? '--jsonOutputFile' : '--outputFile';

    const args = ['--json', '--useStderr', outputArg, this.outputPath];
    if (this.watchMode) {
      args.push(this.watchAll ? '--watchAll' : '--watch');
    }
    if (this.options.testNamePattern) {
      args.push('--testNamePattern', this.options.testNamePattern);
    }
    if (this.options.testFileNamePattern) {
      args.push(this.options.testFileNamePattern);
    }
    if (this.workspace.collectCoverage === true) {
      args.push('--coverage');
    }
    if (this.workspace.collectCoverage === false) {
      args.push('--no-coverage');
    }
    if (this.options.noColor === true) {
      args.push('--no-color');
    }

    const options = {
      shell: this.options.shell
    };

    this.debugprocess = this._createProcess(this.workspace, args, options);
    this.debugprocess.stdout.on('data', data => {
      this._parseOutput(data, false);
    });

    this.debugprocess.stderr.on('data', data => {
      // jest 23 could send test results message to stderr
      // see https://github.com/facebook/jest/pull/4858
      this._parseOutput(data, true);
    });
    this.debugprocess.on('exit', () => {
      this.emit('debuggerProcessExit');
      this.prevMessageTypes.length = 0;
    });

    this.debugprocess.on('error', error => {
      this.emit('terminalError', 'Process failed: ' + error.message);
      this.prevMessageTypes.length = 0;
    });

    this.debugprocess.on('close', () => {
      this.emit('debuggerProcessExit');
      this.prevMessageTypes.length = 0;
    });
  }

  _parseOutput(data, isStdErr) {
    const msgType = this.findMessageType(data);
    switch (msgType) {
      case (_types || _load_types()).messageTypes.testResults:
        (0, (_fs || _load_fs()).readFile)(
          this.outputPath,
          'utf8',
          (err, data) => {
            if (err) {
              const message = `JSON report not found at ${this.outputPath}`;
              this.emit('terminalError', message);
            } else {
              const noTestsFound = this.doResultsFollowNoTestsFoundMessage();
              this.emit('executableJSON', JSON.parse(data), {
                noTestsFound: noTestsFound
              });
            }
          }
        );
        this.prevMessageTypes.length = 0;
        break;
      case (_types || _load_types()).messageTypes.watchUsage:
      case (_types || _load_types()).messageTypes.noTests:
        this.prevMessageTypes.push(msgType);
        this.emit('executableStdErr', data, {
          type: msgType
        });
        break;
      default:
        // no special action needed, just report the output by its source
        if (isStdErr) {
          this.emit('executableStdErr', data, {
            type: msgType
          });
        } else {
          this.emit('executableOutput', data.toString().replace('[2J[H', ''));
        }
        this.prevMessageTypes.length = 0;
        break;
    }

    return msgType;
  }

  runJestWithUpdateForSnapshots(completion, args) {
    const defaultArgs = ['--updateSnapshot'];

    const options = {
      shell: this.options.shell
    };
    const updateProcess = this._createProcess(
      this.workspace,
      [].concat(defaultArgs, _toConsumableArray(args ? args : [])),
      options
    );
    updateProcess.on('close', () => {
      completion();
    });
  }

  closeProcess() {
    if (!this.debugprocess) {
      return;
    }
    if (process.platform === 'win32') {
      // Windows doesn't exit the process when it should.
      (0, (_child_process || _load_child_process()).spawn)('taskkill', [
        '/pid',
        '' + this.debugprocess.pid,
        '/T',
        '/F'
      ]);
    } else {
      this.debugprocess.kill();
    }
    delete this.debugprocess;
  }

  findMessageType(buf) {
    const str = buf.toString('utf8', 0, 58);
    if (str === 'No tests found related to files changed since last commit.') {
      return (_types || _load_types()).messageTypes.noTests;
    }

    if (/^\s*Watch Usage\b/.test(str)) {
      return (_types || _load_types()).messageTypes.watchUsage;
    }

    if (str.trim().startsWith('Test results written to')) {
      return (_types || _load_types()).messageTypes.testResults;
    }
    return (_types || _load_types()).messageTypes.unknown;
  }

  doResultsFollowNoTestsFoundMessage() {
    if (this.prevMessageTypes.length === 1) {
      return (
        this.prevMessageTypes[0] ===
        (_types || _load_types()).messageTypes.noTests
      );
    }

    if (this.prevMessageTypes.length === 2) {
      return (
        this.prevMessageTypes[0] ===
          (_types || _load_types()).messageTypes.noTests &&
        this.prevMessageTypes[1] ===
          (_types || _load_types()).messageTypes.watchUsage
      );
    }

    return false;
  }
}
exports.default = Runner;
